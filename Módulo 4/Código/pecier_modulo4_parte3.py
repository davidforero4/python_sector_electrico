# -*- coding: utf-8 -*-
"""PECIER_Modulo4_parte3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UMhEuSI40nouMiSW3exQzHpxnyl5kITh

# Día 4 Parte 3: Aplicaciones en Sistemas Eléctricos de Numpy

## Ejemplos

**Ejemplo 4.11:**

Vamos a simular una señal distorsionada (fundamental + tercer y quinto armónico), y luego calcular su THD usando NumPy.
"""

import numpy as np
import matplotlib.pyplot as plt

# Generar vector de tiempo
t = np.linspace(0, 0.1, 1000)  # 1000 muestras en 0.1s
f = 50  # Frecuencia fundamental

# Señal con fundamental y armónicos
senal = 220 * np.sin(2 * np.pi * f * t) \
      + 30 * np.sin(2 * np.pi * 3 * f * t) \
      + 15 * np.sin(2 * np.pi * 5 * f * t)

# FFT y frecuencia asociada
fft_senal = np.fft.fft(senal)
frecs = np.fft.fftfreq(len(senal), d=t[1] - t[0])
magnitudes = np.abs(fft_senal) / len(senal)

# Obtener solo parte positiva del espectro
positivas = frecs > 0
frecuencias = frecs[positivas]
magnitudes_pos = magnitudes[positivas]

# Buscar índices de múltiplos de la frecuencia fundamental
armonicos = [f * n for n in range(1, 10)]  # 1ra a 9na armónica
indices_armonicos = [np.argmin(np.abs(frecuencias - h)) for h in armonicos]
valores_armonicos = magnitudes_pos[indices_armonicos]

# Cálculo de THD
V1 = valores_armonicos[0]
armonic_sum = np.sqrt(np.sum(np.array(valores_armonicos[1:])**2))
THD = (armonic_sum / V1) * 100  # en porcentaje

print("Magnitudes armónicas:", valores_armonicos)
print(f"THD: {THD:.2f}%")

### Visualización del espectro


plt.figure(figsize=(10, 4))
plt.stem(frecuencias, magnitudes_pos, basefmt=" ")
plt.title("Espectro Armónico de la Señal")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud (V)")
plt.grid(True)
plt.show()

"""###  Resultado esperado

Picos en:

- **50 Hz** (fundamental)
- **150 Hz** (3er armónico)
- **250 Hz** (5to armónico)

Y el THD calculado estará en torno a un **15-20%**, dependiendo de la amplitud relativa de los armónicos.

### Interpretación del THD

| Rango de THD (%)     | Interpretación                             |
|----------------------|--------------------------------------------|
| 0–5%                 | Muy buena calidad (típico en redes limpias)|
| 5–10%                | Aceptable, pero se debe monitorear         |
| >10%                 | Potencialmente problemático                |
| >20%                 | Necesidad urgente de corrección            |
"""

import numpy as np

# Datos de ejemplo
V_rms = 220# Voltios
I_rms = 10 # Amperios
phi = np.radians(30)# 30° de desfase

# Cálculo de potencia activa, reactiva y aparente
P = V_rms * I_rms * np.cos(phi)# Potencia activa [W]
Q = V_rms * I_rms * np.sin(phi)# Potencia reactiva [VAR]
S = V_rms * I_rms# Potencia aparente [VA]

print(f"""
Resultados:
- Potencia Activa (P): {P:.2f} W
- Potencia Reactiva (Q): {Q:.2f} VAR
- Potencia Aparente (S): {S:.2f} VA
- Factor de Potencia: {np.cos(phi):.2f}
""")

"""Observaciones:
- Usamos funciones trigonométricas de NumPy para manejar el desfase
- `np.radians()` convierte grados a radianes para cálculos matemáticos

## Ejercicios

**Ejercicio 4.11:** Observe el funcionamiento y describa la utilidad del siguiente código:
"""

arr = np.arange(10)
arr.reshape(2,5)

# Espacio para resolver el ejercicio

"""**Ejercicio 4.12:** Observe el funcionamiento y describa la utilidad del siguiente código:"""

a = np.array([1,2,3,2,3,4,3,4,5,6])
b = np.array([7,2,10,2,7,4,9,4,9,8])
np.intersect1d(a,b)

"""**Ejercicio 4.13:** Observe el funcionamiento y describa la utilidad del siguiente código:"""

rand_arr = np.random.random((5,3))
np.set_printoptions(precision=3)
rand_arr

# Espacio para resolver el ejercicio

"""## 3. Proyecto Integrador: Analizador de Eficiencia

### 3.1 Sistema Completo de Monitoreo

"""

import numpy as np
import pandas as pd

# Variables globales
V_nominal = 220
datos = []

def agregar_medicion(V, I, phi, t):
    """Agrega una medición al conjunto de datos"""
    P = V * I * np.cos(phi)
    Q = V * I * np.sin(phi)
    S = V * I
    pf = np.cos(phi)

    datos.append({
        'Tiempo': t,
        'Tensión': V,
        'Corriente': I,
        'P_activa': P,
        'P_reactiva': Q,
        'P_aparente': S,
        'Factor_potencia': pf
    })

def calcular_eficiencia(P_util):
    """Calcula la eficiencia a partir de los datos registrados"""
    P_total = sum(med['P_activa'] for med in datos)
    return (P_util / P_total) * 100

def generar_reporte():
    """Genera un resumen estadístico del comportamiento del sistema"""
    df = pd.DataFrame(datos)
    reporte = {
        'Energía Total [kWh]': df['P_activa'].sum() / 1000,
        'Factor de Potencia Promedio': df['Factor_potencia'].mean(),
        'Pérdidas Estimadas [W]': df['P_aparente'].sum() - df['P_activa'].sum()
    }
    return reporte

# Simulación: 24 horas de mediciones
for t in range(24):
    V = 220 + 10 * np.random.randn()
    I = 8 + 2 * np.sin(2 * np.pi * t / 24)
    phi = np.radians(25 * np.random.rand())
    agregar_medicion(V, I, phi, t)

# Mostrar resultados
print("Reporte de eficiencia energética:")
print(generar_reporte())

"""## Proyecto de ejemplo: Analizador de Calidad de Energía

**Objetivo:** Desarrollar un script que calcule los principales indicadores de calidad de energía: valores RMS de tensión y corriente, factor de potencia, distorsión armónica total (THD) y desbalance de fases.

### Código Completo:


"""

import numpy as np

# Datos trifásicos simulados (tensión y corriente para cada fase)
datos_trifasicos = {
    'tension_R': np.array([220, 221, 219, 220, 221]),
    'corriente_R': np.array([10, 11, 10.5, 10.8, 11.2]),
    'tension_S': np.array([220, 221, 219, 220, 221]),
    'corriente_S': np.array([10, 10.5, 10.7, 10.6, 10.9]),
    'tension_T': np.array([220, 221, 218, 219, 220]),
    'corriente_T': np.array([9.8, 10.3, 10.1, 10.2, 10.4]),
    'frecuencia_muestreo': 6400  # Hz
}

# 1. Valores RMS de tensión y corriente
tension_RMS = {
    'R': np.sqrt(np.mean(datos_trifasicos['tension_R']**2)),
    'S': np.sqrt(np.mean(datos_trifasicos['tension_S']**2)),
    'T': np.sqrt(np.mean(datos_trifasicos['tension_T']**2)),
}

corriente_RMS = {
    'R': np.sqrt(np.mean(datos_trifasicos['corriente_R']**2)),
    'S': np.sqrt(np.mean(datos_trifasicos['corriente_S']**2)),
    'T': np.sqrt(np.mean(datos_trifasicos['corriente_T']**2)),
}

print(f"RMS de tensión: {tension_RMS}")
print(f"RMS de corriente: {corriente_RMS}")

# 2. Factor de potencia (coseno de fase entre tensión y corriente)
def factor_de_potencia(tension, corriente):
    return np.mean(tension * corriente) / (np.sqrt(np.mean(tension**2)) * np.sqrt(np.mean(corriente**2)))

fp_R = factor_de_potencia(datos_trifasicos['tension_R'], datos_trifasicos['corriente_R'])
fp_S = factor_de_potencia(datos_trifasicos['tension_S'], datos_trifasicos['corriente_S'])
fp_T = factor_de_potencia(datos_trifasicos['tension_T'], datos_trifasicos['corriente_T'])

print(f"Factor de potencia: R = {fp_R:.2f}, S = {fp_S:.2f}, T = {fp_T:.2f}")

# 3. Distorsión Armónica Total (THD)
def calcular_THD(tension, corriente, frecuencia_base):
    fft_tension = np.fft.fft(tension)
    fft_corriente = np.fft.fft(corriente)
    frecs = np.fft.fftfreq(len(tension), d=1/datos_trifasicos['frecuencia_muestreo'])

    # Calculamos el THD de cada fase
    armónicos_tension = np.abs(fft_tension[1:])  # Excluimos la componente DC
    armónicos_corriente = np.abs(fft_corriente[1:])
    THD_tension = np.sqrt(np.sum(armónicos_tension**2)) / np.abs(fft_tension[0])
    THD_corriente = np.sqrt(np.sum(armónicos_corriente**2)) / np.abs(fft_corriente[0])

    return THD_tension, THD_corriente

THD_tension, THD_corriente = calcular_THD(datos_trifasicos['tension_R'], datos_trifasicos['corriente_R'], 50)
print(f"THD de tensión: {THD_tension:.2f}")
print(f"THD de corriente: {THD_corriente:.2f}")

# 4. Desbalance de fases
def desbalance_fases(corrientes):
    corriente_media = np.mean(corrientes, axis=0)
    desbalance = (np.max(corriente_media) - np.min(corriente_media)) / np.mean(corriente_media) * 100
    return desbalance

desbalance = desbalance_fases([datos_trifasicos['corriente_R'], datos_trifasicos['corriente_S'], datos_trifasicos['corriente_T']])
print(f"Desbalance de fases: {desbalance:.2f}%")
```