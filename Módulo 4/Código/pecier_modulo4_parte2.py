# -*- coding: utf-8 -*-
"""PECIER_Modulo4_parte2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qb7hgk5CN7CWZbuZrYqVeVt3Ck6UWo2n

# Día 4 Parte 2: Aplicaciones en Sistemas Eléctricos de Numpy

## Ejemplos

**Ejemplo 4.8:** Operaciones matemáticas
"""

import numpy as np

# Datos
tensiones = np.array([220.5, 221.3, 219.8, 220.2, 222.1])

# Calcular el valor RMS (Root Mean Square) de las tensiones
tensiones_rms = np.sqrt(np.mean(tensiones**2))

"""**Ejemplo 4.9:** Slicing de arrays"""

import numpy as np

sistema_trifasico = np.array([
    [220.1, 219.8, 220.5],  # Fase R
    [219.9, 220.2, 220.0],  # Fase S
    [220.3, 220.1, 219.7]   # Fase T
])

# Obtener la primera fase del sistema trifásico
fase_R = sistema_trifasico[0, :]

"""- Aquí seleccionamos la **primera fila** del array `sistema_trifasico`, que corresponde a la fase **R**.
- El uso de `:` indica que queremos **todos los valores de esa fila**.
"""

# Obtener valores impares del array de tensiones
tensiones_impares = tensiones[1::2]

"""- Este slicing selecciona desde el **índice 1** (el segundo elemento) hasta el final, **tomando de a dos elementos**.
- Útil para separar muestras alternadas, como por ejemplo lecturas tomadas en condiciones distintas (día/noche, etc.).

## Tabla de slicing en arrays NumPy

Supongamos que tenemos el siguiente array unidimensional:

```python
arr = np.array([10, 20, 30, 40, 50, 60])
# Índices:      0   1   2   3   4   5
```

| Expresión | Resultado             | Descripción                                                                 |
|-----------|------------------------|-----------------------------------------------------------------------------|
| `arr[:]`         | `[10 20 30 40 50 60]` | Todo el array completo                                                      |
| `arr[0]`         | `10`                  | Elemento en la posición 0                                                  |
| `arr[-1]`        | `60`                  | Último elemento (índice negativo)                                          |
| `arr[1:4]`       | `[20 30 40]`          | Desde índice 1 (incluido) hasta 4 (excluido)                               |
| `arr[:3]`        | `[10 20 30]`          | Desde el inicio hasta índice 3 (excluido)                                  |
| `arr[3:]`        | `[40 50 60]`          | Desde índice 3 hasta el final                                              |
| `arr[::2]`       | `[10 30 50]`          | Elementos con paso de 2 (pares por índice)                                 |
| `arr[1::2]`      | `[20 40 60]`          | Elementos impares (por índice)                                             |
| `arr[::-1]`      | `[60 50 40 30 20 10]` | Array invertido (útil para análisis en reversa o señales de prueba)        |
| `arr[2:5:2]`     | `[30 50]`             | Desde índice 2 hasta 5 (excluido), con paso de 2                           |

```python
mat = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])
# Índices:
# Fila 0: [1 2 3]
# Fila 1: [4 5 6]
# Fila 2: [7 8 9]
```

| Expresión         | Resultado                    | Descripción                                   |
|------------------|------------------------------|-----------------------------------------------|
| `mat[0]`          | `[1 2 3]`                    | Primera fila                                  |
| `mat[:, 0]`       | `[1 4 7]`                    | Primera columna                               |
| `mat[1, :]`       | `[4 5 6]`                    | Toda la segunda fila                          |
| `mat[1:3, 1:]`    | `[[5 6] [8 9]]`              | Submatriz desde fila 1 a 2, columna 1 a 2     |
| `mat[::-1, :]`    | `[[7 8 9] [4 5 6] [1 2 3]]`  | Matriz invertida por filas                    |
| `mat[:, ::-1]`    | `[[3 2 1] [6 5 4] [9 8 7]]`  | Matriz invertida por columnas                 |

**Ejemplo 4.10:** Álgebra lineal
"""

import numpy as np

# Matriz de coeficientes (resistencias y conexiones del circuito)
A = np.array([[5, -2],
              [-2, 4]])

# Vector de términos independientes (fuentes de corriente/tensión)
b = np.array([10, -5])

# Cálculo de las tensiones en los nodos
voltajes_nodales = np.linalg.solve(A, b)
print("Voltajes en los nodos:", voltajes_nodales)

"""## Ejercicios

**Ejercicio 4.5:** Análisis de código. Observe el siguiente código y agregue líneas de comentarios para explicar su funcionamiento.
"""

V = 480 * np.exp(1j * np.radians(0))
I = 25 * np.exp(1j * np.radians(-30))

S = V * np.conj(I)
P, Q = S.real, S.imag

fp_deseado = 0.95
Q_comp = P * (np.tan(np.arccos(fp_deseado)) - Q

print(f"Compensación necesaria: {abs(Q_comp):.2f} VAR")

# Espacio para resolver el ejercicio
V = 480 * np.exp(1j * np.radians(0))
I = 25 * np.exp(1j * np.radians(-30))

S = V * np.conj(I)
P, Q = S.real, S.imag

fp_deseado = 0.95
Q_comp = P * (np.tan(np.arccos(fp_deseado)) - Q

print(f"Compensación necesaria: {abs(Q_comp):.2f} VAR")

"""**Ejercicio 4.6:** Encuentre y corrija los errores en el siguiente código."""

import numpy as np

V = np.array([220, 221, 219, 220])
I = np.array([10, 10.5, 9.8])  # Array más corto

P = V * I
print("Potencias:", P)

# Espacio para resolver el ejercicio.

"""**Error esperado:** `ValueError: operands could not be broadcast together`

**Pista:** Verificar que ambos arrays tengan la misma dimensión antes de realizar la operación.

**Ejercicio 4.7:** Corrija el siguiente código que intenta acceder al último valor de un array.
"""

import numpy as np

valores = np.array([100, 200, 300])
print("Último valor:", valores[3])

# Espacio para resolver el ejercicio

"""**Error esperado:** `IndexError: index 3 is out of bounds`

**Pista:** Recordar que los índices comienzan en 0.

**Ejercicio 4.8:** Explicar el error en que cae el siguiente código:
"""

import numpy as np

P = np.array([500, 0, 300])
S = np.array([600, 0, 400])  # Atención a la división por cero

fp = P / S
print("Factor de Potencia:", fp)

# Espacio para resolver el ejercicio

"""**Ejercicio 4.9:** Corrija el siguiente código para que pueda funcionar"""

valores = [220, 221, 219]
rms = sqrt(sum(valores**2) / len(valores))
print("Valor RMS:", rms)

# Espacio para resolver el ejercicio

"""**Pista:** Importar correctamente las funciones desde NumPy y asegurarnos de que la lista esté convertida en array.

**Ejercicio 4.10:** Corrija el error al crear la matriz identidad
"""

import numpy as np

identidad = np.eye[4]
print(identidad)

# Espacio para resolver el ejercicio

"""**Pista:** `np.eye` es una función; debe usarse con paréntesis, no con corchetes.

## Ejemplo adicional:  Sistema Completo de Monitoreo
"""

import numpy as np
import pandas as pd

# Variables globales
V_nominal = 220
datos = []

def agregar_medicion(V, I, phi, t):
    """Agrega una medición al conjunto de datos"""
    P = V * I * np.cos(phi)
    Q = V * I * np.sin(phi)
    S = V * I
    pf = np.cos(phi)

    datos.append({
        'Tiempo': t,
        'Tensión': V,
        'Corriente': I,
        'P_activa': P,
        'P_reactiva': Q,
        'P_aparente': S,
        'Factor_potencia': pf
    })

def calcular_eficiencia(P_util):
    """Calcula la eficiencia a partir de los datos registrados"""
    P_total = sum(med['P_activa'] for med in datos)
    return (P_util / P_total) * 100

def generar_reporte():
    """Genera un resumen estadístico del comportamiento del sistema"""
    df = pd.DataFrame(datos)
    reporte = {
        'Energía Total [kWh]': df['P_activa'].sum() / 1000,
        'Factor de Potencia Promedio': df['Factor_potencia'].mean(),
        'Pérdidas Estimadas [W]': df['P_aparente'].sum() - df['P_activa'].sum()
    }
    return reporte

# Simulación: 24 horas de mediciones
for t in range(24):
    V = 220 + 10 * np.random.randn()
    I = 8 + 2 * np.sin(2 * np.pi * t / 24)
    phi = np.radians(25 * np.random.rand())
    agregar_medicion(V, I, phi, t)

# Mostrar resultados
print("Reporte de eficiencia energética:")
print(generar_reporte())